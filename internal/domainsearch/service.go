package domainsearch

import (
	"fmt"
	"math/rand"
	"sync"
	"time"

	domainsearchv1 "github.com/olaysco/domain-search-llm/internal/gen/domainsearch/v1"
	"github.com/olaysco/domain-search-llm/internal/llm"
	"github.com/olaysco/domain-search-llm/internal/provider"
)

// Service implements the DomainSearchServiceServer generated by protoc.
type SearchService struct {
	domainsearchv1.UnimplementedDomainSearchServiceServer
	llmSuggester  *llm.LLMSuggester
	priceProvider provider.PriceProvider

	rnd  *rand.Rand
	lock sync.Mutex
}

// NewService constructs a Service with a time-based random seed.
func NewSearchService(llmSusggester *llm.LLMSuggester, priceProvider provider.PriceProvider) *SearchService {
	return &SearchService{
		rnd:           rand.New(rand.NewSource(time.Now().UnixNano())),
		llmSuggester:  llmSusggester,
		priceProvider: priceProvider,
	}
}

// CheckPrice proxies the upstream price provider stream to the caller.
func (s *SearchService) CheckPrice(req *domainsearchv1.SearchPricesRequest, stream domainsearchv1.DomainSearchService_CheckPriceServer) error {
	ctx := stream.Context()

	if req == nil {
		return nil
	}

	llmQuery := llm.AISuggestionRequest{
		Query:      req.Query,
		MaxResults: 10,
	}
	llmResponse, err := s.llmSuggester.GenerateDomainSuggestions(ctx, llmQuery)
	if err != nil {
		return err
	}
	fmt.Println(llmResponse)

	wg := sync.WaitGroup{}
	for _, suggestion := range llmResponse {
		wg.Add(1)
		go func() {
			s.priceProvider.StreamPrices(ctx, suggestion.Domain, func(resp *domainsearchv1.SearchPricesResponse) error {
				if resp == nil {
					wg.Done()
					return nil
				}
				resp.SimilarityScore = fmt.Sprintf("%.2f", suggestion.Score)
				fmt.Println(resp)
				wg.Done()
				return stream.Send(resp)
			})
		}()
	}

	wg.Wait()
	return nil
}
