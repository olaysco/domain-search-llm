package domainsearch

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"strings"
	"sync"
	"time"

	domainsearchv1 "github.com/olaysco/domain-search-llm/internal/gen/domainsearch/v1"
	"github.com/olaysco/domain-search-llm/internal/llm"
	"github.com/olaysco/domain-search-llm/internal/provider"
)

// Service implements the DomainSearchServiceServer generated by protoc.
type SearchService struct {
	domainsearchv1.UnimplementedDomainSearchServiceServer
	llmSuggester  *llm.LLMSuggester
	llmAgent      *llm.LLMAgent
	priceProvider provider.PriceProvider

	rnd  *rand.Rand
	lock sync.Mutex
}

// NewService constructs a Service with a time-based random seed.
func NewSearchService(llmSusggester *llm.LLMSuggester, llmAgent *llm.LLMAgent, priceProvider provider.PriceProvider) *SearchService {
	return &SearchService{
		rnd:           rand.New(rand.NewSource(time.Now().UnixNano())),
		llmSuggester:  llmSusggester,
		llmAgent:      llmAgent,
		priceProvider: priceProvider,
	}
}

// CheckPrice proxies the upstream price provider stream to the caller.
func (s *SearchService) CheckPrice(req *domainsearchv1.SearchPricesRequest, stream domainsearchv1.DomainSearchService_CheckPriceServer) error {
	ctx, cancel := context.WithCancel(stream.Context())
	defer cancel()

	if req == nil {
		return nil
	}

	llmQuery := llm.AISuggestionRequest{
		Query:      req.Query,
		MaxResults: 10,
		Context:    buildLLMContext(req),
	}
	llmResponse, err := s.llmSuggester.GenerateDomainSuggestions(ctx, llmQuery)
	if err != nil {
		fmt.Println(err)
		return err
	}

	var wg sync.WaitGroup
	errCh := make(chan error, 1)

	for _, suggestion := range llmResponse {
		wg.Add(1)
		go func() {
			defer wg.Done()
			if err := s.priceProvider.StreamPrices(ctx, suggestion.Domain, func(resp *domainsearchv1.SearchPricesResponse) error {
				if resp == nil {
					return nil
				}
				if price := resp.GetPrice(); price != nil {
					price.SimilarityScore = suggestion.Score
					fmt.Println(price)
				}
				return stream.Send(resp)
			}); err != nil && !errors.Is(err, context.Canceled) {
				select {
				case errCh <- err:
				default:
				}
				cancel()
			}
		}()
	}

	wg.Wait()
	select {
	case err := <-errCh:
		fmt.Println(err)
		return err
	default:
		return nil
	}
}

func (s *SearchService) CheckPriceAgent(req *domainsearchv1.SearchPricesRequest, stream domainsearchv1.DomainSearchService_CheckPriceAgentServer) error {
	ctx, cancel := context.WithCancel(stream.Context())
	defer cancel()

	if req == nil {
		return nil
	}

	llmQuery := llm.AISuggestionRequest{
		Query:      req.Query,
		MaxResults: 10,
		Context:    buildLLMContext(req),
	}

	// Execute agent to get domain suggestions
	agentResp, err := s.llmAgent.ExecuteWithTools(ctx, llmQuery)
	if err != nil {
		fmt.Println(err)
		return err
	}

	// Stream prices for each domain suggestion
	var wg sync.WaitGroup
	errCh := make(chan error, 1)

	for _, suggestion := range agentResp.Domains {
		wg.Add(1)
		go func(domain llm.DomainSuggestion) {
			defer wg.Done()
			// Fetch prices from provider (cache is handled internally)
			if err := s.priceProvider.StreamPrices(ctx, domain.Domain, func(resp *domainsearchv1.SearchPricesResponse) error {
				if resp == nil {
					return nil
				}
				if price := resp.GetPrice(); price != nil {
					price.SimilarityScore = domain.Score
					fmt.Println(price)
				}
				return stream.Send(resp)
			}); err != nil && !errors.Is(err, context.Canceled) {
				select {
				case errCh <- err:
				default:
				}
				cancel()
			}
		}(suggestion)
	}

	wg.Wait()
	select {
	case err := <-errCh:
		fmt.Println(err)
		return err
	default:
		return nil
	}
}

// Helper functions for safe pointer dereferencing
func getFloat32Value(ptr *float32) float32 {
	if ptr == nil {
		return 0
	}
	return *ptr
}

func getBoolValue(ptr *bool, defaultVal bool) bool {
	if ptr == nil {
		return defaultVal
	}
	return *ptr
}

func buildLLMContext(req *domainsearchv1.SearchPricesRequest) map[string]interface{} {
	if req == nil {
		return nil
	}
	ctx := make(map[string]interface{})
	if filter := req.GetFilter(); filter != nil {
		if domain := filter.GetDomain(); domain != nil {
			if included := strings.TrimSpace(domain.GetIncludedTldNames()); included != "" {
				ctx["preferred_tlds"] = included
			}
			if excluded := strings.TrimSpace(domain.GetExcludedTldNames()); excluded != "" {
				ctx["excluded_tlds"] = excluded
			}
		}
	}
	if len(ctx) == 0 {
		return nil
	}
	return ctx
}
